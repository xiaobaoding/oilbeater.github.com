---
layout: post
title: "linux 信号处理机制简介"
description: "鉴于后面把进程的形象给彻底毁掉了，我提前声明一下，进程是有尊严的有节操的，当然大部分人可能也看不到毁形象那一段了。"
tagline: "Hack the life!"
category: 
img: "http://lh6.googleusercontent.com/-vRXcYw7V7fg/T69fVsIkNaI/AAAAAAAAAIw/Y3KgmC33VbI/s512/linux.jpg"
tags: [linux , 源码阅读]
---
<div>
<p>
    鉴于后面把进程的形象给彻底毁掉了，我提前声明一下，进程是有尊严的有节操的，当然大部分人可能也看不到毁形象那一段。为什么介绍linux要从信号开始呢，当然是为了保证能讲明白，因为翻了翻书我发现这一部分是最简单的了，所以呢，就讲这个吧，顺便把之前源码阅读的东西总结一下。
</p>
<h2>信号是什么东西呢？</h2>
<p>两个直观的感受，你在终端运行一个程序然后摁一下Ctrl+c就是向正在运行的程序发送了一个终止信号，程序就被终止了；在终端kill一个pid相当于发送9号杀死这个进程；在终端运行<code>kill -l</code>
就可以查看系统的所有信号。   </p> 
<img src="http://lh6.googleusercontent.com/-vRXcYw7V7fg/T69fVsIkNaI/AAAAAAAAAIw/Y3KgmC33VbI/s512/linux.jpg" style="float:left;width:243px;height:208px">	
<p>有了上面这些直观感受，那么信号本质是什么呢？信号本质上是一种向一个进程通知发生异步事件的机制，是在软件层次上对中断的一种模拟。这种通知机制可以用于通知硬件消息like上面的感受1，也可以用来进行进程间通信like上面的感受2，还可以用来通知一些程序错误如除0、非法内存访问。异步是说进程没有对信号进行实时监控，不必等待信号到来，事实上进程也根本不知道信号什么时候会来。一个进程本来在欢乐的跑着突然就被你一个ctrl+c给杀死了，飞来横祸呀。至于说是一种软中断，是因为在原理上，一个进程受到一个信号与处理器收到一个中断请求可以说是一样的，本来在欢乐的跑着就从你一个脚上给你来一个高电平。</p>
<hr>
<h2>信号分类</h2>
<p>通过<code>kill -l</code>可以看到linux现在支持64个信号，注意一下信号不是从0编号的而是从1编号。其中前32为标准（Standard）信号，后32为实时（Real-time）信号。好吧，什么是标准信号，什么又是实时信号。</p>
<p>在遥远的古代是只有标准信号的，那时候它也不叫标准信号，就叫信号，它是一种十分简单的机制。先说一下信号的运行，当信号发送到程序时并不是立即执行而是等待某个时机再执行，在这个时机还没到来的时候你一个类型的信号无论发多少个都只记录一个，就好比有32个信箱每个信箱只能收一封信，多的就扔吧；另一方面信号的响应也是不保证顺序的，你发送信号的顺序和信号响应的顺序可能根本就没什么关系，因为古代人类都比较简单嘛。后来人类不断发展又想要可以响应一个类型的多个信号又想保证响应顺序，实时信号就诞生了，其实就是加了个sigqueue这么个队列数据结构，需求就被满足了。但是之前的简单信号已经成为了实际上的标准，而实时信号的应用也还不如前者广，两者就共存了。</p>
<blockquote>Tips：实时信号的信号范围由SIGRTMIN和SIGRTMAX两个宏来决定，编程使用实时信号的话可以使用SIGRTMIN+n指定一个信号而不是直接一个数字，因为万一标准信号数量又增加呢，直接写数字编码可能就会出现bug，这两个宏也为将来信号的灵活扩展提供了基础。同时也是灌输一个编程不要使用魔数的原则。</blockquote>
<hr>
<h2>信号响应</h2>
UNIX对前32个信号都有默认的响应方式，分为以下5类：
<ul>
<li>Term：终止进程</li>
<li>Ign：忽略该信号</li>
<li>Core：终止进程并保存内存信息</li>
<li>Stop：停止进程</li>
<li>Cont：有停止就有恢复进程</li>
</ul>
<p>当然只有5个响应方法怎么够呢，not fashion 于是sigaction()这个系统调用就上了，通过它可以给一个信号绑定一个函数来当作信号处理函数，你就可以在这个函数里面胡作非为了。可是你胡作非为了内核开发人员又感觉不爽了于是就设了两个信号你是改不了的，以显示他们不可动摇的地位，这两个信号就是9号SIGKILL和19号SIGSTOP，所以你也就不能定义Ctrl+c和Ctrl+z发送出来的信号的处理方式了。</p>
<blockquote>Tips：当然你足够邪恶的话可以定义这两个组合键指向别的操作。</blockquote>
<hr>
<h2>信号处理机制</h2>
<p>废话这么多终于开始讲机制了。</p>
<h3>信号发送和接收</h3>
<p>最简单的理解，一个程序给另一个程序发了个短信，通过中国移不动或者中国联不通的网络，另一个程序的手机就收到了，一个信号就算发送成功了。具体来说就是一个程序调用一个发送信号的系统调用例如。然后内核就扮演运营商的角色把信号扔给另一个进程。我们知道进程在内存里还是有很多家当的，主要维护了一个进程描述符，里面有着pid呀，进程状态呀，优先级呀一堆不可告人的秘密，等以后有空了我给大家八卦一下。</p>
<p> pending 和 signal 是两个挂起信号队列,为什么要有两个呀?因为一个是私有的队列一个是共享的队列。为什么有私有和共享之分呀?因为一个是针对轻量级进程的一个是针对线程组的?这两个又是什么东西呀?本小农发现这里开始不好说了.为什么有私有和共享之分呀？因为一个是针对轻量级进程的一个是针对线程组的？这两个又是什么东西呀？本小农发现这里开始不好说了……简单说，Linux是没有进程和线程的，有的只有轻量级进程，如果一组轻量级进程之间可以共享资源，那么就组成一个相当于线程组的东西，也就相当于一个线程，换句话说Linux是用轻量级进程这个东西模拟多线程，感兴趣同学可以看一下LWP，总之这里知道有两个信号挂起队列就好了，如果前面LWP的东西没看懂，你这里可以认为一个是记录的给线程的信号，一个记录的给进程的信号。sighand就简单多了就是记录64个信号对应的处理函数的入口地址，当然还有其他好多辅助的数据结构，但主要就是这个功能。如果能大致看懂下面这张图说明你还没晕。</p>
<img src="http://lh5.googleusercontent.com/-nKNOz8JsqSI/T69fWX0E6WI/AAAAAAAAAIw/Nh-2zidTbGo/s640/signal_struct.jpg" alt="signal struct">
<p>回到手机短信，内核把短信发给进程是干了什么事呢？就是找个队列把信号插进去。当然进程也是有尊严的，不会让你随便插的如果是标准信号的话你只能插一次，如果这个信号还在的话就不让你插了，不像对实时信号那么随便想插多少插多少。有的进程比较专一，如果有一个信号插进来他会设置一个屏蔽位不让别的信号插，可以对比一下中断，处理器有时也会设一个中断屏蔽位有木有。</p>
<h3>信号的查看与处理</h3>
<p>短信发过来了，不一定就被看到了，这也是异步说的意思，那么什么时候进程才会发现我有一个新的短消息呢？原来进程是在从内核态这个黑暗的角落到用户态切换之前偷偷的看一眼短信，看看都有谁插了进来，然后把他们处理掉，再回到用户态光明正大的去接客。那么什么时候进程会去内核态这个小黑屋呢，主要有三种情况：</p>
<ul>
<li>执行系统调用</li>
<li>处理中断异常</li>
<li>进程调度上CPU</li>
</ul>
</div>
