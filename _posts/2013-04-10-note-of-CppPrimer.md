---
layout: default
published: false
---

#C++ Primer 笔记

又看了一遍，这是第三遍了，这次是真看，还是有很多没懂，记下摘得句子，加点自己的感悟。

建议每个内置类型的对象都要初始化。虽然这样做并不总是必需的，但是会更加容易和安全，除非你确定忽略初始化式不会带来风险。（就是变量要及时初始化，静态变量会有默认初始化，动态变量就没准了，要小心）

程序员经常在调试过程中插入输出语句，这些语句都应该刷新输出流。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致程序错误推断崩溃位置。（就是及时用endl或者flush来刷新缓冲，其实调试时如果用IDE的话感觉意义不大，频繁刷新缓冲区还会带来性能下降，尤其在文件流里）

通常把一个对象定义在它首次使用的地方是一个很好的办法。

头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数。（多次include会导致重复定义）

头文件应该含有保护符，即使这些头文件不会被其他头文件包含。编写头文件保护符并不困难，而且如果头文件被包含多次，它可以避免难以理解的编译错误。

通常，头文件中应该只定义确实必要的东西。不要写using 请养成这个好习惯。（曾经的教训）

由于 getline 函数返回时丢弃换行符，换行符将不会存储在 string 对象中。

任何存储 string 的 size 操作结果的变量必须为 string::size_type 类型。特别重要的是，不要把 size 的返回值赋给一个 int 变量。（书上把不要翻译成还要，害得我纠结半天，如果是int编译会有warning）

string 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。如果两个 string 对象长度不同，且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象。

使用 size_type 类型时，必须指出该类型是在哪里定义的。vector 类型总是包括总是包括 vector 的元素类型：     vector<int>::size_type        // ok
    	 vector::size_type            // error
         
由 end 操作返回的迭代器并不指向 vector 中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完 vector 中所有元素。

？const_iterator c++11 中auto如何区别const_iterator 和 iterator

string 对象和 bitsets 对象之间是反向转化的：string 对象的最右边字符（即下标最大的那个字符）用来初始化 bitset 对象的低阶位（即下标为 0 的位）。当用 string 对象初始化 bitset 对象时，记住这一差别很重要。（一个和惯性思维相悖，又和仔细思考相符的东西）

* 指针初始化和赋值操作的约束
	* 0 值常量表达式例如，在编译时可获得 0 值的整型 const 对象或字面值常量 0。
	* 类型匹配的对象的地址。
	* 另一对象末的下一地址。
	* 同类型的另一个有效指针。

对于动态分配的数组，其元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。（所以给vector初始化只能用一对迭代器了）

理论上，回收数组时缺少空方括号对，至少会导致运行时少释放了内存空间，从而产生内存泄漏（memory leak）。对于某些系统和/或元素类型，有可能会带来更严重的运行时错误。因此，在释放动态数组时千万别忘了方括号对。

c_str 返回的数组并不保证一定是有效的，接下来对 st2 的操作有可能会改变 st2 的值，使刚才返回的数组失效。如果程序需要持续访问该数据，则应该复制 c_str 函数返回的数组。

与普通数组一样，使用多维数组名时，实际上将其自动转换为指向该数组第一个元素的指针。(从里往外，从右往左)

	int *ip[4]; // array of pointers to int    
	int (*ip)[4]; // pointer to an array of 4 ints

对于位操作符，由于系统不能确保如何处理其操作数的符号位，所以强烈建议使用unsigned整型操作数。（不同体系结构有不同处理方式）

一般而言，标准库提供的 bitset 操作更直接、更容易阅读和书写、正确使用的可能性更高。而且，bitset 对象的大小不受 unsigned 数的位数限制。通常来说，bitset 优于整型数据的低级直接位操作。利用set和reset来设置位不用复杂的位操作。

只有在必要时才使用后置操作符，因为前置操作需要做的工作更少，只需加 1 后返回加 1 后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加 1 之前的值作为操作的结果，对于 int 型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能会花费更大的代价。（果然很抠性能）

一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。（为什么不在语言级别设置，难道删除的指针有特别用处）

new非配失败抛出bad_alloc异常。（和malloc的0不一样了啊！）

不将数组转换为指针的例外情况有：数组用作取地址（&）操作符的操作数或 sizeof 操作符的操作数时，或用数组对数组的引用进行初始化时，不会将数组转换为指针。（其实只要记住数组和指针是两个类型，只是存在一个隐式转换就好了）

C++ 还提供了另外两种指针转换：指向任意数据类型的指针都可转换为 void* 类型；整型数值常量 0 可转换为任意指针类型。（其他常量值也可以吧？）

dynamic_cast 支持运行时识别指针或引用所指向的对象。

const_cast ，顾名思义，将转换掉表达式的 const 性质。类似地，除了添加或删除 const 特性，用 const_cast 符来执行其他任何类型转换，都会引起编译错误。

编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。

reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。



